Fields
	grammar cannot determine correclty call to fields
Lambdas
	 Add -> notation
Monads
	 monads are structural (have filter, map and flatmap) because of unit but can use exentions + Monad<T> interface
	 Promisses   do (something) then (something) else (otherthing)
	 Maybe
	 Collection (aka Enumerable)
Properties	 
	 use in/out in properties for get/set
UAP	 
	 parentesis are optional for zero arguments methods. 

Native	 
	 Peer classes and native
	 native import ?
	 native = call to subjacent plataform api. this must be 
Meta-Compiler	
	 compiler plugins and delegation sintax  Regex<| ashdads |> = não é legal, mas ter alguma forma de fazer
	 		Color color = #3AF90;
	 Seria legal o que leva ao uso de implicits
	 Optional parameters vs overloading vs generics vs compatability with javascritpt
Null propagation
	 ?. operator is wrong. No nulls means null aware operations
	 	String? a = ...
	 	Int? b = a.length(); // will be  = a.map(it => it.length); 
	 Optional type and abreviations ( String? )  
More literals	 
	all numeric literals are rational numbers
	 imaginary unit is 'i' and 2i means  Rational("2") * Complex.I;
	 literals for urls (?)
	 literals for regex
	  intervals literal
	 list and map literals (javascript like)
	 	list = new List {"a","b","c"} 
		 map = new HashMap { "a": 1, "b": 2 , "c" : 3} 
     Builders like Window { Size = Size { 20, 40} }} equivalente to new : xml alternative + parser
	 Property bag as single loadable/parsable file (JSON style) 
Operatores and Operacional Interfaces	
	 operator for racional division 	
Tuples
	 Because of reeification Tuple is diferent from Tuple<A> and diferente from Tuple<A,B> , etc...
	 Resolver problema de uma classe para cada rank 
	 	[]  =>		Tuple => Tuple<Nothing,Nothing>
	    [A}	=>		Tuple<A> => Tuple<A , Nothing>
	 	[A,B] =>	Tuple<A,B>  => Tuple<A, Tuple<B, Nothing>>
	 	[A,B,C] =>	Tuple<A,B,C> => Tuple<A, Tuple<B, Tuple<C, Nothing>>
	 	[A,B,C,D] =>Tuple<A,B,C, D> => Tuple<A, Tuple<B, Tuple<C, Tuple<D,Noting>>
	 	
	 	interface Tuple<T, N> 
	 	    first: T;
	 	    next : N; 
	 	    
		class Pair<A,B> implements Tuple<A,B>
			last : B	 	    
	 	    
	 Void = Tuple de argumento nenhum
	 	
	 	class Void implements Tuple<Nothing, Nothing>
	 	object Void extends Void;
	 	
	 [a, b,c] short notation
	 A tuple with all types equal is a sequence

	 sintax sugar tuple[0] em vez de tuple.item1  
	 
	 	tuple[0] => tuple.first;
	 	tuple[1] => tuple.next.first;
	 	tuple[2] => tuple.next.next.first;
	 
Reification and Generics
	 resolve generics problem of adding list to a list (and a sequence to a sequence)
Understanding
	 Methods are wrappers arround functions because they curry arround 'this'. static types do not curry
	  constructors are curried Actions like constructor.apply(this): Void. 
Insight 
	 Ceylon does not have new, but forces classes to camel case !!	
	 Language shoul help comunication and documentation.   
Imutability
	 value classes :  public val class Rational , to mean the class is imutable. properties must also be val or only have methods
	 value classes are "primitives" and be safely shared by actors: actor.send(message). Message must be imutable or seriablizable.
	 Mark interfaces Imutable and Serializable and have : class Actor {   Void send<T extends Imutable | Serializable>(T msg)  }
	 
	 Constructors and methods vs functions and apply.  Client("A") <=> Client.apply("A") <=> Client.Companion.apply("A")
Compilation 	 
	 metadata read from .class
	 definition of a classpath = project structure for compiler (maven like)
Syntax
	 identify dead code
	 identify out of range literals
	