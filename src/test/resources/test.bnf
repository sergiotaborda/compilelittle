unit = packageDeclaration? ,  importDeclarations? , typeDeclarations?;
packageDeclaration = 'package' packageName ';' ;
packageName = identifier | identifier '.' packageName;
importDeclarations = importDeclaration importDeclarations | empty;
importDeclaration = singleTypeImportDeclaration | typeImportOnDemandDeclaration;
singleTypeImportDeclaration = 'import' typeName ';' ;
typeImportOnDemandDeclaration = 'import' packageName '.' '*' ';';
typeDeclarations = typeDeclaration typeDeclarations | empty;
typeName = identifier | packageName '.' identifier;
typeDeclaration = classDeclaration | interfaceDeclaration | empty ;
classDeclaration = classModifiers? 'class' identifier superDeclaration? interfaces? classBody;
classModifiers = classModifier classModifiers | empty;
classModifier = 'public' |'abstract' | 'final';
superDeclaration = 'extends' classType;
interfaces = 'implements' interfaceTypeList;
interfaceTypeList = interfaceType moreTypeList;
moreTypeList =  ',' interfaceTypeList | empty;
classBody = '{' classBodyDeclarations? '}';
classBodyDeclarations = classBodyDeclaration classBodyDeclarations | empty;
classBodyDeclaration = classMemberDeclaration | staticInitializer | constructorDeclaration;
classMemberDeclaration = fieldDeclaration | methodDeclaration;
staticInitializer = 'static' block;
constructorDeclaration = constructorModifiers? constructorDeclarator throws? constructorBody;
constructorModifiers = constructorModifier constructorModifiers | empty;
constructorModifier = 'public' | 'protected' | 'private';
constructorDeclarator = simpleTypeName '(' formalParameterList? ')';
formalParameterList = formalParameter moreFormalParameterList
moreFormalParameterList = ',' formalParameterList | empty;
formalParameter = type variableDeclaratorId;
throws = 'throws' classTypeList;
classTypeList = classType | classTypeList ',' classType;
constructorBody = '{' explicitConstructorInvocation? blockStatements? '}';
explicitConstructorInvocation = 'this' '(' argumentList? ')' | 'super' '(' argumentList? ')';
fieldDeclaration = fieldModifiers? type variableDeclarators ';' ;
fieldModifiers = fieldModifier fieldModifiers | empty;
fieldModifier = 'public' | 'protected' | 'private' | 'static' | 'final' | 'transient' | 'volatile';
variableDeclarators = variableDeclarator moreVariableDeclarators;
moreVariableDeclarators =  ',' variableDeclarators | empty;
variableDeclarator= variableDeclaratorId | variableDeclaratorId '=' variableInitializer;
variableDeclaratorId = identifier | variableDeclaratorId '[' ']';
variableInitializer= expression | arrayInitializer;
methodDeclaration= methodHeader methodBody;
methodHeader = methodModifiers? resultType methodDeclarator throws? ;
resultType= type | 'void';
methodModifiers= methodModifier methodModifiers |  empty;
methodModifier = 'public' | 'protected' | 'private' | 'static' | 'abstract' | 'final' | 'synchronized' | 'native' ;
methodDeclarator= identifier '(' formalParameterList? ')' ;
methodBody = block | empty ;
interfaceDeclaration = interfaceModifiers? 'interface' identifier extendsInterfaces? interfaceBody;
interfaceModifiers = interfaceModifier | interfaceModifiers interfaceModifiers;
interfaceModifier = 'public' | 'abstract';
extendsInterfaces = 'extends' interfaceType | extendsInterfaces ',' interfaceType;
interfaceBody= '{' interfaceMemberDeclarations? '}';
interfaceMemberDeclarations= interfaceMemberDeclaration interfaceMemberDeclarations | empty;
interfaceMemberDeclaration= constantDeclaration | abstractMethodDeclaration;
constantDeclaration = constantModifiers type variableDeclarator;
constantModifiers = constantModifier constantModifiers | empty;
constantModifier = 'public' | 'static' | 'final' ;
abstractMethodDeclaration = abstractMethodModifiers? resultType methodDeclarator throws? ;
abstractMethodModifiers= abstractMethodModifier abstractMethodModifiers | empty;
abstractMethodModifier = 'public' | 'abstract';
arrayInitializer= '{' variableInitializers? '}';
variableInitializers = variableInitializer moreVariableInitializers;
moreVariableInitializers = ',' variableInitializer | variableInitializers;
type= primitiveType | referenceType;
primitiveType= numericType | 'boolean';
numericType = integralType | floatingPointType;
integralType = 'byte' | 'short' | 'int' | 'long' | 'char';
floatingPointType=  'float' | 'double';
referenceType= classOrInterfaceType | arrayType;
classOrInterfaceType = classType | interfaceType;
classType= typeName;
interfaceType = typeName;
arrayType= type '[' ']';
block = '{' blockStatements? '}';
blockStatements = blockStatement blockStatements | empty;
blockStatement = localVariableDeclarationStatement | statement;
localVariableDeclarationStatement= localVariableDeclaration;
localVariableDeclaration= type variableDeclarators;
statement= statementWithoutTrailingSubstatement | labeledStatement | ifThenStatement | ifThenElseStatement | whileStatement | forStatement;
statementNoShortIf= statementWithoutTrailingSubstatement | labeledStatementNoShortIf | ifThenElseStatementNoShortIf | whileStatementNoShortIf | forStatementNoShortIf;
statementWithoutTrailingSubstatement= block | emptyStatement | expressionStatement | switchStatement | doStatement | breakStatement | continueStatement | returnStatement | synchronizedStatement | throwsStatement | tryStatement;
emptyStatement= empty;
labeledStatement= identifier ':' statement;
labeledStatementNoShortIf= identifier ':' statementNoShortIf;
expressionStatement= statementExpression;
statementExpression= assignment | preincrementExpression | postincrementExpression | predecrementExpression | postdecrementExpression | methodInvocation | classInstanceCreationExpression;
ifThenStatement = 'if' '(' expression ')' statement;
ifThenElseStatement = 'if' '(' expression ')' statementNoShortIf 'else' statement;
ifThenElseStatementNoShortIf = 'if' '(' expression ')' statementNoShortIf 'else' statementNoShortIf;
switchStatement = 'switch' '(' expression ')' switchBlock;
switchBlock = '{' switchBlockStatementGroups? switchLabels? '}';
switchBlockStatementGroups = switchBlockStatementGroups switchBlockStatementGroups | empty;
switchBlockStatementGroup= switchLabels blockStatements;
switchLabels= switchLabel switchLabels | empty;
switchLabel = 'case' constantExpression ':' | 'default' ':' ;
whileStatement= 'while' '(' expression ')' statement;
whileStatementNoShortIf = 'while' '(' expression ')' statementNoShortIf;
doStatement= 'do' statement 'while' '(' expression ')' ';';
forStatement= 'for' '(' forInit? ';' expression? ';' forUpdate? ')' statement;
forStatementNoShortIf = 'for' '(' forInit? ';' expression? ';' forUpdate? ')' statementNoShortIf;
forInit= statementExpressionList | localVariableDeclaration;
forUpdate = statementExpressionList;
statementExpressionList = statementExpression moreStatementExpressionList;
moreStatementExpressionList = ',' statementExpression | empty;
breakStatement = 'break' identifier? ';' ;
continueStatement= 'continue' identifier? ';' ;
returnStatement= 'return' expression? ';';
throwsStatement= 'throw' expression ';';
synchronizedStatement= 'synchronized' '(' expression ')' block;
tryStatement= 'try' block catches | 'try' block catches finally;
catches = catchClause catches | empty;
catchClause= 'catch' '(' formalParameter ')' block;
finally = 'finally' block;
constantExpression= expression;
expression = assignmentExpression;
assignmentExpression= conditionalExpression | assignment;
assignment = leftHandSide assignmentOperator assignmentExpression;
leftHandSide = expressionName | fieldAccess | arrayAccess;
assignmentOperator = '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=';
conditionalExpression= conditionalOrExpression | conditionalOrExpression '?' expression ':' conditionalExpression;
conditionalOrExpression = conditionalAndExpression | conditionalOrExpression '||' conditionalAndExpression;
conditionalAndExpression = inclusiveOrExpression | conditionalAndExpression '&&' inclusiveOrExpression;
inclusiveOrExpression= exclusiveOrExpression | inclusiveOrExpression | exclusiveOrExpression;
exclusiveOrExpression = andExpression | exclusiveOrExpression '^' andExpression;
andExpression = equalityExpression | andExpression '&' equalityExpression;
equalityExpression = relationalExpression | equalityExpression '==' relationalExpression | equalityExpression '!=' relationalExpression;
relationalExpression = shiftExpression | relationalExpression '<' shiftExpression | relationalExpression '>' shiftExpression | relationalExpression '<=' shiftExpression | relationalExpression '>=' shiftExpression | relationalExpression 'instanceof' shiftExpression;
shiftExpression = additiveExpression | shiftExpression '<<' additiveExpression | shiftExpression '>>' additiveExpression | shiftExpression '>>>' additiveExpression;
additiveExpression = multiplicativeExpression | additiveExpression '+' multiplicativeExpression | additiveExpression '-' multiplicativeExpression;
multiplicativeExpression = unaryExpression | multiplicativeExpression '*' unaryExpression | multiplicativeExpression '/'unaryExpression | multiplicativeExpression '%' unaryExpression;
castExpression = '(' primitiveType ')' unaryExpression | '(' referenceType ')' unaryExpressionNotPlusMinus;
unaryExpression = preincrementExpression | predecrementExpression | '+' unaryExpression | '-' unaryExpression | unaryExpressionNotPlusMinus;
preincrementExpression = '++' unaryExpression;
predecrementExpression = '--' unaryExpression;
unaryExpressionNotPlusMinus = postfixExpression | '~' unaryExpression | '!' unaryExpression | castExpression;
postdecrementExpression= postfixExpression '--';
postincrementExpression= postfixExpression '++';
postfixExpression = primary | expressionName | postincrementExpression | postdecrementExpression;
methodInvocation= methodName '(' argumentList? ')' | primary '.' identifier  '(' argumentList? ')' | 'super' '.' identifier '(' argumentList? ')';
fieldAccess= primary '.' identifier | 'super' '.' identifier;
primary = primaryNoNewArray | arrayCreationExpression;
primaryNoNewArray = literal | 'this' | '(' expression ')' | classInstanceCreationExpression | fieldAccess | methodInvocation | arrayAccess;
classInstanceCreationExpression = 'new' classType '(' argumentList? ')';
argumentList = expression | argumentList ',' expression;
arrayCreationExpression = 'new' primitiveType dimExprs dims? | 'new' classOrInterfaceType dimExprs dims?;
dimExprs= dimExpr | dimExprs dimExpr;
dimExpr= '[' expression ']';
dims= '[' ']' | dims '[' ']';
arrayAccess = expressionName '[' expression ']' | primaryNoNewArray '[' expression ']';
simpleTypeName = identifier;
expressionName= identifier | ambiguousName '.' identifier;
methodName= identifier | ambiguousName '.' identifier;
ambiguousName= identifier |ambiguousName '.' identifier;
literal= integerLiteral | floatingPointLiteral | booleanLiteral | characterLiteral | stringLiteral | nullLiteral;
integerLiteral = decimalIntegerLiteral | hexIntegerLiteral | octalIntegerLiteral;
decimalIntegerLiteral= decimalNumeral integerTypeSuffix?;
hexIntegerLiteral = hexNumeral integerTypeSuffix?;
octalIntegerLiteral= octalNumeral integerTypeSuffix?;
integerTypeSuffix= 'l' | 'L';
decimalNumeral = '0' | nonZeroDigit digits?;
digits= digit | digits digit;
digit= '0' | nonZeroDigit;
nonZeroDigit = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
hexNumeral = '0' 'x' hexDigit | '0' 'X' hexDigit | hexNumeral hexDigit;
hexDigit  = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F';
octalNumeral = '0' octalDigit | octalNumeral octalDigit;
octalDigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7';
floatingPointLiteral = digits '.' digits? exponentPart? floatTypeSuffix?;
exponentPart= exponentIndicator signedInteger;
exponentIndicator= 'e' | 'E';
signedInteger = sign? digits;
sign= '+' | '-';
floatTypeSuffix = 'f' | 'F' | 'd' | 'D';
booleanLiteral= 'true' | 'false';
nullLiteral= 'null';