unit = packageDeclaration ,  importDeclarations?, typeDeclarations;
packageDeclaration  = 'package' , qualifiedName , ';' ;
qualifiedName = identifier | qualifiedName , '.' , identifier; 
importDeclarations = importDeclaration | importDeclarations , importDeclaration;
importDeclaration = 'import' , qualifiedName , ';' ;
typeDeclarations = typeDeclaration | typeDeclarations ,  typeDeclaration;
typeDeclaration = classDeclaration | interfaceDeclaration;
classDeclaration = annotations?, 'class', qualifiedName, genericTypesDeclaration, superDeclaration, classBody;
interfaceDeclaration = annotations?, 'interface', qualifiedName, genericTypesDeclaration, extendsInterfaces? , interfaceBody;
extendsInterfaces = 'extends', type | extendsInterfaces, ',', type;
interfaceBody= '{', interfaceMemberDeclarations ,'}' | '{' , '}';
interfaceMemberDeclarations= interfaceMemberDeclaration | interfaceMemberDeclarations , interfaceMemberDeclaration;
interfaceMemberDeclaration= constantDeclaration | abstractMethodDeclaration;
constantDeclaration =  annotations?, type , variableName, ';' | annotations?, type , variableName, '=' , expression , ';';
abstractMethodDeclaration = annotations?, returnType, identifier ,'(', formalParameterList , ')'  , ';' | annotations?, returnType, identifier ,'(', ')' , ';' ;
annotations = annotation | annotations , annotation;
annotation = 'public' | 'private' | 'abstract' | 'final';
genericTypesDeclaration = empty | '<' , parametricTypes , '>';
superDeclaration = empty | 'extends' , type;
classBody = '{',classBodyDeclarations ,'}' | '{' ,'}';
classBodyDeclarations = classBodyDeclaration | classBodyDeclarations, classBodyDeclaration;
classBodyDeclaration = classMemberDeclaration;
classMemberDeclaration = fieldDeclaration | methodDeclaration;
fieldDeclaration =  type , variableName, ';' | type , variableName, '=' , expression , ';';
type = qualifiedName |  qualifiedName , '<' , parametricTypes , '>';
parametricTypes = type | parametricTypes , ',', type;
variableName = identifier;
methodDeclaration= methodHeader , methodBody;
methodHeader = annotations?, returnType, identifier ,'(', formalParameterList , ')' | annotations?, returnType, identifier ,'(', ')'; 
methodBody = block ;
block =  '{' , '}' | '{' , blockStatements , '}';
returnType = type | 'void';
formalParameterList = formalParameter | formalParameterList, ',', formalParameter;
formalParameter =  type, variableName;
blockStatements = blockStatement | blockStatements, blockStatement;
blockStatement = localVariableDeclarationStatement | statement;
statement= expressionStatement | whileStatement | forStatement | ifThenStatement | ifThenElseStatement | ifThenElseIfStatement | switchStatement | returnStatement | breakStatement | continueStatement | tryStatement;
returnStatement=  'return', expression, ';' |  'return', ';';
breakStatement = 'break', identifier, ';' | 'break', ';' ;
continueStatement= 'continue', identifier, ';' | 'continue', ';';
tryStatement= 'try', resource?, block, catches?, finally?;
resource = '(' , assignment, ')';
catches = catchClause | catches , catchClause;
catchClause= 'catch', '(', formalParameter ,')', block;
finally = 'finally', block;
expressionStatement= statementExpression , ';';
statementExpression= assignment | postincrementExpression  | postdecrementExpression | methodInvocation | classInstanceCreationExpression;
localVariableDeclarationStatement= type, variableName , ';' | type, variableName , '=' , expression, ';';
whileStatement= 'while', '(', expression, ')',  block | 'while', '(', expression, ')';
forStatement= 'for',  '(', iterationType , 'in', expression ,')', block;
iterationType = type , variableName;
ifThenStatement = 'if', '(', expression ,')', block;
ifThenElseStatement = 'if', '(', expression ,')', block , 'else', block;
ifThenElseIfStatement =  conditionsList | conditionsList , endAlternative;
conditionsList = 'if', '(', expression ,')', block , 'else', 'if', '(', expression ,')', block;
endAlternative = 'else', block | 'else' , 'if', '(', expression ,')', block , endAlternative;
switchStatement = 'switch', '(', constantExpression, ')', switchBlock;
switchBlock = '{', switchLabels, '}';
switchLabels= switchLabel | switchLabels, switchLabel;
switchLabel = 'case', '(',  expression , ')' , block | 'default' , block;
constantExpression= leftHandSide;
expression = variableName | conditionalExpression | assignment;
conditionalExpression= conditionalOrExpression | ternaryExpression;
ternaryExpression = conditionalOrExpression, '?', expression, ':', conditionalExpression;
conditionalOrExpression = conditionalAndExpression | conditionalOrExpression ,'||', conditionalAndExpression;
conditionalAndExpression = inclusiveOrExpression | conditionalAndExpression, '&&', inclusiveOrExpression;
inclusiveOrExpression= exclusiveOrExpression | inclusiveOrExpression '|' exclusiveOrExpression;
exclusiveOrExpression = andExpression | exclusiveOrExpression, '^', andExpression;
andExpression = equalityExpression | andExpression, '&', equalityExpression;
equalityExpression = relationalExpression | equalityExpression, equalityOperator, relationalExpression;
equalityOperator = '==' | '!=';
relationalExpression = shiftExpression | relationalExpression, compareOperator, shiftExpression | relationalExpression, 'instanceof', shiftExpression;
compareOperator = '<' | '>' | '<=' | '>=';
shiftExpression = additiveExpression | shiftExpression, shiftOperator, additiveExpression;
shiftOperator = '<<' | '>>' | '>>>';
additiveExpression = multiplicativeExpression | additiveExpression, '+', multiplicativeExpression | additiveExpression, '-', multiplicativeExpression;
multiplicativeExpression = rangeExpression |  multiplicativeExpression ,multiplicativeOperator, rangeExpression;
multiplicativeOperator = '*' | '/' | '%';
rangeExpression = unaryExpression | unaryExpression , '..', unaryExpression;
unaryExpression = unaryExpressionNotPlusMinus | unaryAditiveOperator, unaryExpression;
unaryAditiveOperator = '+' | '-'| '++' |'--';
unaryExpressionNotPlusMinus = postfixExpression | unaryMultiplicativeOperator, unaryExpression;
unaryMultiplicativeOperator = '~' | '!' ;
postfixExpression = primary | identifier | postincrementExpression  | postdecrementExpression;
postincrementExpression = postfixExpression, '++';
postdecrementExpression = postfixExpression, '--';
assignment = leftHandSide, assignmentOperator, expression; 
assignmentOperator = '=' |'*=' | '/=' |'%=' |'+=' | '<<=' |'>>=' | '>>>=' | '&=' | '^=' | '|=';
leftHandSide = variableWrite | fieldAccess | arrayAccess;
variableWrite = identifier;
fieldAccess= primary ,'.', identifier | 'super', '.', identifier;
arrayAccess = qualifiedName ,'[', expression, ']' | primary, '[', expression, ']';
primary = literal | 'this' | '(', expression ,')' | fieldAccess | arrayAccess | classInstanceCreationExpression | methodInvocation;
classInstanceCreationExpression = 'new' ,type, '(', argumentList, ')' | 'new' ,type, '(', ')';
argumentList = expression | argumentList, ',', expression;
methodInvocation= qualifiedName, '(', argumentList?, ')' | primary ,'.', identifier , '(', argumentList? ,')' | 'super', '.', identifier, '(', argumentList?, ')';
literal= numberLiteral | booleanLiteral | stringLiteral | nullLiteral;
numberLiteral = number;
booleanLiteral= 'true' | 'false';
stringLiteral = text;
nullLiteral = 'null';