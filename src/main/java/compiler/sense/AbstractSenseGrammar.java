package compiler.sense;
import compiler.AbstractGrammar;
import compiler.parser.EmptyTerminal;
import compiler.parser.Identifier;
import compiler.parser.NonTerminal;
import compiler.parser.Terminal;
import compiler.parser.Text;
import compiler.parser.Numeric;

public abstract class AbstractSenseGrammar extends AbstractGrammar {

public AbstractSenseGrammar (){
	super();
}

protected NonTerminal defineGrammar() {

NonTerminal unit = addNonTerminal(NonTerminal.of("unit"));
NonTerminal packageDeclaration = addNonTerminal(NonTerminal.of("packageDeclaration"));
NonTerminal qualifiedName = addNonTerminal(NonTerminal.of("qualifiedName"));
NonTerminal importDeclarations = addNonTerminal(NonTerminal.of("importDeclarations"));
NonTerminal importDeclaration = addNonTerminal(NonTerminal.of("importDeclaration"));
NonTerminal typeDeclarations = addNonTerminal(NonTerminal.of("typeDeclarations"));
NonTerminal typeDeclaration = addNonTerminal(NonTerminal.of("typeDeclaration"));
NonTerminal classDeclaration = addNonTerminal(NonTerminal.of("classDeclaration"));
NonTerminal superDeclaration = addNonTerminal(NonTerminal.of("superDeclaration"));
NonTerminal classBody = addNonTerminal(NonTerminal.of("classBody"));
NonTerminal classBodyDeclarations = addNonTerminal(NonTerminal.of("classBodyDeclarations"));
NonTerminal classBodyDeclaration = addNonTerminal(NonTerminal.of("classBodyDeclaration"));
NonTerminal classMemberDeclaration = addNonTerminal(NonTerminal.of("classMemberDeclaration"));
NonTerminal fieldDeclaration = addNonTerminal(NonTerminal.of("fieldDeclaration"));
NonTerminal type = addNonTerminal(NonTerminal.of("type"));
NonTerminal variableDeclarator = addNonTerminal(NonTerminal.of("variableDeclarator"));
NonTerminal variableName = addNonTerminal(NonTerminal.of("variableName"));
NonTerminal methodDeclaration = addNonTerminal(NonTerminal.of("methodDeclaration"));
NonTerminal methodHeader = addNonTerminal(NonTerminal.of("methodHeader"));
NonTerminal methodBody = addNonTerminal(NonTerminal.of("methodBody"));
NonTerminal block = addNonTerminal(NonTerminal.of("block"));
NonTerminal returnType = addNonTerminal(NonTerminal.of("returnType"));
NonTerminal formalParameterList = addNonTerminal(NonTerminal.of("formalParameterList"));
NonTerminal formalParameter = addNonTerminal(NonTerminal.of("formalParameter"));
NonTerminal blockStatements = addNonTerminal(NonTerminal.of("blockStatements"));
NonTerminal blockStatement = addNonTerminal(NonTerminal.of("blockStatement"));
NonTerminal statement = addNonTerminal(NonTerminal.of("statement"));
NonTerminal statementWithoutTrailingSubstatement = addNonTerminal(NonTerminal.of("statementWithoutTrailingSubstatement"));
NonTerminal expressionStatement = addNonTerminal(NonTerminal.of("expressionStatement"));
NonTerminal statementExpression = addNonTerminal(NonTerminal.of("statementExpression"));
NonTerminal localVariableDeclarationStatement = addNonTerminal(NonTerminal.of("localVariableDeclarationStatement"));
NonTerminal localVariableDeclaration = addNonTerminal(NonTerminal.of("localVariableDeclaration"));
NonTerminal whileStatement = addNonTerminal(NonTerminal.of("whileStatement"));
NonTerminal forStatement = addNonTerminal(NonTerminal.of("forStatement"));
NonTerminal iterationType = addNonTerminal(NonTerminal.of("iterationType"));
NonTerminal ifThenStatement = addNonTerminal(NonTerminal.of("ifThenStatement"));
NonTerminal ifThenElseStatement = addNonTerminal(NonTerminal.of("ifThenElseStatement"));
NonTerminal expression = addNonTerminal(NonTerminal.of("expression"));
NonTerminal conditionalExpression = addNonTerminal(NonTerminal.of("conditionalExpression"));
NonTerminal ternaryExpression = addNonTerminal(NonTerminal.of("ternaryExpression"));
NonTerminal conditionalOrExpression = addNonTerminal(NonTerminal.of("conditionalOrExpression"));
NonTerminal conditionalAndExpression = addNonTerminal(NonTerminal.of("conditionalAndExpression"));
NonTerminal inclusiveOrExpression = addNonTerminal(NonTerminal.of("inclusiveOrExpression"));
NonTerminal exclusiveOrExpression = addNonTerminal(NonTerminal.of("exclusiveOrExpression"));
NonTerminal andExpression = addNonTerminal(NonTerminal.of("andExpression"));
NonTerminal equalityExpression = addNonTerminal(NonTerminal.of("equalityExpression"));
NonTerminal equalityOperator = addNonTerminal(NonTerminal.of("equalityOperator"));
NonTerminal relationalExpression = addNonTerminal(NonTerminal.of("relationalExpression"));
NonTerminal compareOperator = addNonTerminal(NonTerminal.of("compareOperator"));
NonTerminal shiftExpression = addNonTerminal(NonTerminal.of("shiftExpression"));
NonTerminal shiftOperator = addNonTerminal(NonTerminal.of("shiftOperator"));
NonTerminal additiveExpression = addNonTerminal(NonTerminal.of("additiveExpression"));
NonTerminal aditionOperator = addNonTerminal(NonTerminal.of("aditionOperator"));
NonTerminal multiplicativeExpression = addNonTerminal(NonTerminal.of("multiplicativeExpression"));
NonTerminal multiplicativeOperator = addNonTerminal(NonTerminal.of("multiplicativeOperator"));
NonTerminal unaryExpression = addNonTerminal(NonTerminal.of("unaryExpression"));
NonTerminal unaryAditiveOperator = addNonTerminal(NonTerminal.of("unaryAditiveOperator"));
NonTerminal unaryExpressionNotPlusMinus = addNonTerminal(NonTerminal.of("unaryExpressionNotPlusMinus"));
NonTerminal unaryMultiplicativeOperator = addNonTerminal(NonTerminal.of("unaryMultiplicativeOperator"));
NonTerminal castExpression = addNonTerminal(NonTerminal.of("castExpression"));
NonTerminal postfixExpression = addNonTerminal(NonTerminal.of("postfixExpression"));
NonTerminal postincrementExpression = addNonTerminal(NonTerminal.of("postincrementExpression"));
NonTerminal postdecrementExpression = addNonTerminal(NonTerminal.of("postdecrementExpression"));
NonTerminal assignment = addNonTerminal(NonTerminal.of("assignment"));
NonTerminal leftHandSide = addNonTerminal(NonTerminal.of("leftHandSide"));
NonTerminal assignmentOperator = addNonTerminal(NonTerminal.of("assignmentOperator"));
NonTerminal fieldAccess = addNonTerminal(NonTerminal.of("fieldAccess"));
NonTerminal arrayAccess = addNonTerminal(NonTerminal.of("arrayAccess"));
NonTerminal primary = addNonTerminal(NonTerminal.of("primary"));
NonTerminal classInstanceCreationExpression = addNonTerminal(NonTerminal.of("classInstanceCreationExpression"));
NonTerminal argumentList = addNonTerminal(NonTerminal.of("argumentList"));
NonTerminal methodInvocation = addNonTerminal(NonTerminal.of("methodInvocation"));
NonTerminal methodCall = addNonTerminal(NonTerminal.of("methodCall"));
NonTerminal literal = addNonTerminal(NonTerminal.of("literal"));
NonTerminal numberLiteral = addNonTerminal(NonTerminal.of("numberLiteral"));
NonTerminal booleanLiteral = addNonTerminal(NonTerminal.of("booleanLiteral"));
NonTerminal stringLiteral = addNonTerminal(NonTerminal.of("stringLiteral"));
NonTerminal nullLiteral = addNonTerminal(NonTerminal.of("nullLiteral"));
NonTerminal maybeImportDeclarations = addNonTerminal(NonTerminal.of("maybeImportDeclarations"));


unit.setRule(packageDeclaration.add(maybeImportDeclarations).add(typeDeclarations));
packageDeclaration.setRule(Terminal.of("package").add(qualifiedName).add(Terminal.of(";")));
qualifiedName.setRule(Identifier.instance().or(qualifiedName.add(Terminal.of(".")).add(Identifier.instance())));
importDeclarations.setRule(importDeclaration.or(importDeclarations.add(importDeclaration)));
importDeclaration.setRule(Terminal.of("import").add(qualifiedName).add(Terminal.of(";")));
typeDeclarations.setRule(typeDeclaration.or(typeDeclarations.add(typeDeclaration)));
typeDeclaration.setRule(classDeclaration);
classDeclaration.setRule(Terminal.of("class").add(qualifiedName).add(superDeclaration).add(classBody));
superDeclaration.setRule(EmptyTerminal.instance().or(Terminal.of("extends").add(qualifiedName)));
classBody.setRule(Terminal.of("{").add(classBodyDeclarations).add(Terminal.of("}")).or(Terminal.of("{").add(Terminal.of("}"))));
classBodyDeclarations.setRule(classBodyDeclaration.or(classBodyDeclarations.add(classBodyDeclaration)));
classBodyDeclaration.setRule(classMemberDeclaration);
classMemberDeclaration.setRule(fieldDeclaration.or(methodDeclaration));
fieldDeclaration.setRule(type.add(variableDeclarator).add(Terminal.of(";")));
type.setRule(qualifiedName);
variableDeclarator.setRule(variableName.or(variableName.add(Terminal.of("=")).add(expression)));
variableName.setRule(Identifier.instance());
methodDeclaration.setRule(methodHeader.add(methodBody));
methodHeader.setRule(returnType.add(Identifier.instance()).add(Terminal.of("(")).add(formalParameterList).add(Terminal.of(")")).or(returnType.add(Identifier.instance()).add(Terminal.of("(")).add(Terminal.of(")"))));
methodBody.setRule(block);
block.setRule(Terminal.of("{").add(Terminal.of("}")).or(Terminal.of("{").add(blockStatements).add(Terminal.of("}"))));
returnType.setRule(type.or(Terminal.of("void")));
formalParameterList.setRule(formalParameter.or(formalParameterList.add(Terminal.of(",")).add(formalParameter)));
formalParameter.setRule(type.add(variableName));
blockStatements.setRule(blockStatement.or(blockStatements.add(blockStatement)));
blockStatement.setRule(localVariableDeclarationStatement.or(statement));
statement.setRule(statementWithoutTrailingSubstatement.or(whileStatement.or(forStatement.or(ifThenStatement.or(ifThenElseStatement)))));
statementWithoutTrailingSubstatement.setRule(expressionStatement);
expressionStatement.setRule(statementExpression.add(Terminal.of(";")));
statementExpression.setRule(assignment.or(postincrementExpression.or(postdecrementExpression.or(methodInvocation.or(classInstanceCreationExpression)))));
localVariableDeclarationStatement.setRule(localVariableDeclaration.add(Terminal.of(";")));
localVariableDeclaration.setRule(type.add(variableDeclarator));
whileStatement.setRule(Terminal.of("while").add(Terminal.of("(")).add(expression).add(Terminal.of(")")).add(block).or(Terminal.of("while").add(Terminal.of("(")).add(expression).add(Terminal.of(")"))));
forStatement.setRule(Terminal.of("for").add(Terminal.of("(")).add(iterationType).add(Terminal.of("in")).add(expression).add(Terminal.of(")")).add(block).or(Terminal.of("for").add(Terminal.of("(")).add(iterationType).add(Terminal.of("in")).add(Identifier.instance()).add(Terminal.of(")"))));
iterationType.setRule(type.add(variableName));
ifThenStatement.setRule(Terminal.of("if").add(Terminal.of("(")).add(expression).add(Terminal.of(")")).add(block));
ifThenElseStatement.setRule(Terminal.of("if").add(Terminal.of("(")).add(expression).add(Terminal.of(")")).add(block).add(Terminal.of("else")).add(block));
expression.setRule(conditionalExpression.or(assignment));
conditionalExpression.setRule(conditionalOrExpression.or(ternaryExpression));
ternaryExpression.setRule(conditionalOrExpression.add(Terminal.of("?")).add(expression).add(Terminal.of(":")).add(conditionalExpression));
conditionalOrExpression.setRule(conditionalAndExpression.or(conditionalOrExpression.add(Terminal.of("||")).add(conditionalAndExpression)));
conditionalAndExpression.setRule(inclusiveOrExpression.or(conditionalAndExpression.add(Terminal.of("&&")).add(inclusiveOrExpression)));
inclusiveOrExpression.setRule(exclusiveOrExpression.or(inclusiveOrExpression.or(exclusiveOrExpression)));
exclusiveOrExpression.setRule(andExpression.or(exclusiveOrExpression.add(Terminal.of("^")).add(andExpression)));
andExpression.setRule(equalityExpression.or(andExpression.add(Terminal.of("&")).add(equalityExpression)));
equalityExpression.setRule(relationalExpression.or(equalityExpression.add(equalityOperator).add(relationalExpression)));
equalityOperator.setRule(Terminal.of("==").or(Terminal.of("!=")));
relationalExpression.setRule(shiftExpression.or(relationalExpression.add(compareOperator).add(shiftExpression).or(relationalExpression.add(Terminal.of("instanceof")).add(shiftExpression))));
compareOperator.setRule(Terminal.of("<").or(Terminal.of(">").or(Terminal.of("<=").or(Terminal.of(">=")))));
shiftExpression.setRule(additiveExpression.or(shiftExpression.add(shiftOperator).add(additiveExpression)));
shiftOperator.setRule(Terminal.of("<<").or(Terminal.of(">>").or(Terminal.of(">>>"))));
additiveExpression.setRule(multiplicativeExpression.or(additiveExpression.add(aditionOperator).add(multiplicativeExpression)));
aditionOperator.setRule(Terminal.of("+").add(Terminal.of("-")));
multiplicativeExpression.setRule(unaryExpression.or(multiplicativeExpression.add(multiplicativeOperator).add(unaryExpression)));
multiplicativeOperator.setRule(Terminal.of("*").or(Terminal.of("/").or(Terminal.of("%"))));
unaryExpression.setRule(unaryExpressionNotPlusMinus.or(unaryAditiveOperator.add(unaryExpression)));
unaryAditiveOperator.setRule(Terminal.of("+").or(Terminal.of("-").or(Terminal.of("++").or(Terminal.of("--")))));
unaryExpressionNotPlusMinus.setRule(postfixExpression.or(unaryMultiplicativeOperator.add(unaryExpression).or(castExpression)));
unaryMultiplicativeOperator.setRule(Terminal.of("~").or(Terminal.of("!")));
castExpression.setRule(Terminal.of(".").add(Terminal.of("castTo")).add(Terminal.of("(")).add(type).add(Terminal.of(".")).add(Terminal.of("class")).add(Terminal.of(")")));
postfixExpression.setRule(primary.or(Identifier.instance().or(postincrementExpression.or(postdecrementExpression))));
postincrementExpression.setRule(postfixExpression.add(Terminal.of("++")));
postdecrementExpression.setRule(postfixExpression.add(Terminal.of("--")));
assignment.setRule(leftHandSide.add(assignmentOperator).add(expression));
leftHandSide.setRule(Identifier.instance().or(fieldAccess.or(arrayAccess)));
assignmentOperator.setRule(Terminal.of("=").or(Terminal.of("*=").or(Terminal.of("/=").or(Terminal.of("%=").or(Terminal.of("+=").or(Terminal.of("-=").or(Terminal.of("<<=").or(Terminal.of(">>=").or(Terminal.of(">>>=").or(Terminal.of("&=").or(Terminal.of("^=").or(Terminal.of("|=")))))))))))));
fieldAccess.setRule(primary.add(Terminal.of(".")).add(Identifier.instance()).or(Terminal.of("super").add(Terminal.of(".")).add(Identifier.instance())));
arrayAccess.setRule(qualifiedName.add(Terminal.of("[")).add(expression).add(Terminal.of("]")).or(primary.add(Terminal.of("[")).add(expression).add(Terminal.of("]"))));
primary.setRule(literal.or(Terminal.of("this").or(Terminal.of("(").add(expression).add(Terminal.of(")")).or(fieldAccess.or(arrayAccess.or(classInstanceCreationExpression.or(methodInvocation)))))));
classInstanceCreationExpression.setRule(Terminal.of("new").add(type).add(Terminal.of("(")).add(argumentList).add(Terminal.of(")")).or(Terminal.of("new").add(type).add(Terminal.of("(")).add(Terminal.of(")"))));
argumentList.setRule(expression.or(argumentList.add(Terminal.of(",")).add(expression)));
methodInvocation.setRule(methodCall.or(primary.add(Terminal.of(".")).add(methodCall).or(Terminal.of("super").add(Terminal.of(".")).add(methodCall))));
methodCall.setRule(Identifier.instance().add(Terminal.of("(")).add(argumentList).add(Terminal.of(")")).or(Identifier.instance().add(Terminal.of("(")).add(Terminal.of(")"))));
literal.setRule(numberLiteral.or(booleanLiteral.or(stringLiteral.or(nullLiteral))));
numberLiteral.setRule(Numeric.instance());
booleanLiteral.setRule(Terminal.of("true").or(Terminal.of("false")));
stringLiteral.setRule(Text.instance());
nullLiteral.setRule(Terminal.of("null"));
maybeImportDeclarations.setRule(importDeclarations.or(EmptyTerminal.instance()));

	return unit;
}

}
