unit = packageDeclaration ,  importDeclarations?, typeDeclarations;
packageDeclaration  = 'package' , qualifiedName , ';' ;
qualifiedName = identifier | qualifiedName , '.' , identifier; 
importDeclarations = importDeclaration | importDeclarations , importDeclaration;
importDeclaration = 'import' , qualifiedName , ';' ;
typeDeclarations = typeDeclaration | typeDeclarations ,  typeDeclaration;
typeDeclaration = classDeclaration ;
classDeclaration =  'class', qualifiedName, superDeclaration, classBody;
superDeclaration = empty | 'extends' , type;
classBody = '{',classBodyDeclarations ,'}' | '{' ,'}';
classBodyDeclarations = classBodyDeclaration | classBodyDeclarations, classBodyDeclaration;
classBodyDeclaration = classMemberDeclaration;
classMemberDeclaration = fieldDeclaration | methodDeclaration;
fieldDeclaration =  type , variableName, ';' | type , variableName, '=' , expression , ';';
type = qualifiedName |  qualifiedName , '<' , parametricTypes , '>';
parametricTypes = type | parametricTypes , ',', type;
variableName = identifier;
methodDeclaration= methodHeader , methodBody;
methodHeader = returnType, identifier ,'(', formalParameterList , ')' | returnType, identifier ,'(', ')'; 
methodBody = block ;
block =  '{' , '}' | '{' , blockStatements , '}';
returnType = type | 'void';
formalParameterList = formalParameter | formalParameterList, ',', formalParameter;
formalParameter =  type, variableName;
blockStatements = blockStatement | blockStatements, blockStatement;
blockStatement = localVariableDeclarationStatement | statement;
statement= expressionStatement | whileStatement | forStatement | ifThenStatement | ifThenElseStatement | switchStatement | returnStatement | breakStatement | continueStatement | tryStatement;
returnStatement=  'return', expression, ';' |  'return', ';';
breakStatement = 'break', identifier, ';' | 'break', ';' ;
continueStatement= 'continue', identifier, ';' | 'continue', ';';
tryStatement= 'try', resource?, block, catches?, finally?;
resource = '(' , assignment, ')';
catches = catchClause | catches , catchClause;
catchClause= 'catch', '(', formalParameter ,')', block;
finally = 'finally', block;
expressionStatement= statementExpression , ';';
statementExpression= assignment | postincrementExpression  | postdecrementExpression | methodInvocation | classInstanceCreationExpression;
localVariableDeclarationStatement= type, variableName , ';' | type, variableName , '=' , expression, ';';
whileStatement= 'while', '(', expression, ')',  block | 'while', '(', expression, ')';
forStatement= 'for',  '(', iterationType , 'in', expression ,')', block;
iterationType = type , variableName;
ifThenStatement = 'if', '(', expression ,')', block;
ifThenElseStatement = 'if', '(', expression ,')', block , 'else', block;
switchStatement = 'switch', '(', constantExpression, ')', switchBlock;
switchBlock = '{', switchLabels, '}';
switchLabels= switchLabel | switchLabels, switchLabel;
switchLabel = 'case', '(',  expression , ')' , block | 'default' , block;
constantExpression= leftHandSide;
expression = variableName | conditionalExpression | assignment;
conditionalExpression= conditionalOrExpression | ternaryExpression;
ternaryExpression = conditionalOrExpression, '?', expression, ':', conditionalExpression;
conditionalOrExpression = conditionalAndExpression | conditionalOrExpression ,'||', conditionalAndExpression;
conditionalAndExpression = inclusiveOrExpression | conditionalAndExpression, '&&', inclusiveOrExpression;
inclusiveOrExpression= exclusiveOrExpression | inclusiveOrExpression '|' exclusiveOrExpression;
exclusiveOrExpression = andExpression | exclusiveOrExpression, '^', andExpression;
andExpression = equalityExpression | andExpression, '&', equalityExpression;
equalityExpression = relationalExpression | equalityExpression, equalityOperator, relationalExpression;
equalityOperator = '==' | '!=';
relationalExpression = shiftExpression | relationalExpression, compareOperator, shiftExpression | relationalExpression, 'instanceof', shiftExpression;
compareOperator = '<' | '>' | '<=' | '>=';
shiftExpression = additiveExpression | shiftExpression, shiftOperator, additiveExpression;
shiftOperator = '<<' | '>>' | '>>>';
additiveExpression = multiplicativeExpression | additiveExpression, '+', multiplicativeExpression | additiveExpression, '-', multiplicativeExpression;
multiplicativeExpression = unaryExpression |  multiplicativeExpression ,multiplicativeOperator, unaryExpression;
multiplicativeOperator = '*' | '/' | '%';
unaryExpression = unaryExpressionNotPlusMinus | unaryAditiveOperator, unaryExpression;
unaryAditiveOperator = '+' | '-'| '++' |'--';
unaryExpressionNotPlusMinus = postfixExpression | unaryMultiplicativeOperator, unaryExpression;
unaryMultiplicativeOperator = '~' | '!' ;
postfixExpression = primary | identifier | postincrementExpression  | postdecrementExpression;
postincrementExpression = postfixExpression, '++';
postdecrementExpression = postfixExpression, '--';
assignment = leftHandSide, assignmentOperator, expression; 
assignmentOperator = '=' |'*=' | '/=' |'%=' |'+=' | '<<=' |'>>=' | '>>>=' | '&=' | '^=' | '|=';
leftHandSide = variableWrite | fieldAccess | arrayAccess;
variableWrite = identifier;
fieldAccess= primary ,'.', identifier | 'super', '.', identifier;
arrayAccess = qualifiedName ,'[', expression, ']' | primary, '[', expression, ']';
primary = literal | 'this' | '(', expression ,')' | fieldAccess | arrayAccess | classInstanceCreationExpression | methodInvocation;
classInstanceCreationExpression = 'new' ,type, '(', argumentList, ')' | 'new' ,type, '(', ')';
argumentList = expression | argumentList, ',', expression;
methodInvocation =  methodCall | primary ,'.', methodCall | 'super', '.', methodCall;
methodCall = identifier, '(', argumentList, ')' | identifier, '(', ')';
literal= numberLiteral | booleanLiteral | stringLiteral | nullLiteral;
numberLiteral = number;
booleanLiteral= 'true' | 'false';
stringLiteral = text;
nullLiteral = 'null';